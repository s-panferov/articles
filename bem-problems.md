
На текущем месте работы мне пришлось столкнуться с инструментами, которые Яндекс предлагает использовать для разработки проектов по методологии БЕМ. За время моей работы с ними у меня накопилась некоторая структурированная и (как я надеюсь) конструктивная критика этих инструментов. В этой статье я попытаюсь изложить основные мысли о том, что же, по моему мнению, плохо в предлагаемом инструментарии.

В данной статье я не буду подробно расписывать детали реализации методологии, поэтому для того, чтобы понять, о чем идет речь, я предлагаю читателю обратиться к оригинальной документации Яндекса.

В конце статьи будет приведено видение того, как исправить некоторые из перечисленных проблем.

## Проблемы системы сборки: ENB и .deps.js

Для сборки проектов Яндекс предлагает использовать несколько своих собственных сборщиков. Наиболее популярный из них — [enb](https://github.com/enb-make/enb). Помимо черезчур усложненного конфига пробем у него, как такового, нет, за исключением того, что он очень слабо поддерживается сообществом. Этот недостаток присущ всем без исключения инструментам, так что мы рассмотрим его отдельно.

Первая серьезная претензия к сборке у меня появилась тогда, когда я начал разбираться с механизмом управления зависимостями в проекте. Суть заключается в том, что для успешной работы вашего блока вы должны создать для него специальный файл с расширением `.deps.js`, который будет использоваться enb или другим сборщиком для того, чтобы скомпоновать для вас итоговый бандл. Выглядит это как-то так:

```js
// TODO
```

Что тут плохо:

*. Код внутри данного файла не является валидным кодом JavaScript.
*. Содержимое данного файла нужно писать вручную. В него необходимо записывать все блоки и их модификаторы, которые вы используете.

Но самая главная проблема заключается в том, как инструменты реагируют на ваши ошибки при заполнении данного файла. Они не реагируют на них **никак**! В совокупности с тем, что будет сказано ниже про минусы модификаторов, использование такого подхода создает разработчику массу неудобств:

Если ты использовал в коде новый блок — обнови файл. Если ты забыл прописать какой-либо блок или модификатор в зависимости, то их код просто не подключается к проекту, что может привести ваш блок в неконсистентное состояние. В лучшем случае вы сразу увидите случайную ошибку, вызванную отсутствием какой-то используемой функции. В худжем случае (а он бывает гораздо чаще) у вас просто не будет работать какая-либо часть нужной вам функциональности без ошибок и объяснения причин.

То же самое случается, если в библиотеках, которые вы используете, модификатор или блок будет переименован. Вам придется вручную обновить все файлы зависимостей, в которых он используется, и не дай бог вам ошибиться. 

## Проблемы системы сборки: YModules

Для управления зависимостями в JS-коде предлагается использовать собственную модульную систему под названием YModules, которая тесно интегрирована в фреймворк. Она позволяет управлять зависимостями и порядком загрузки JavaScript модулей. 

Официальная статья про [YModules](https://ru.bem.info/tools/bem/modules/) на момент написания данной статьи перечисляет все соображения, которыми авторы руководствовались при ее создании. Ввиду их краткости привожу их здесь:

```
Требования:

1. Асинхронный require модулей
2. Асинхронный provide модулей
3. Возможность передекларации/додекларации модуля

Почему не CommonJS?

Смотри пункты 1, 2 и 3 требований

Почему не AMD?

Смотри пункты 2 и 3 требований
```

Рассмотрим предложенные use-cases подробнее:

1. **Асинхронный require модулей.** Чаще всего асинхнонная загрузка модулей необходима в окружениях, когда модули предполагается догружать с сервера в процессе работы приложения. Не смотря на то, что мне пока не удалось увидеть ни одного реального примера такого использования модульной системы в БЕМ-приложениях, я могу согласиться что такой use-case может иметь место. Однако, асинхронную загрузку модулей умеют осущствлять все современные популярные модульные системы, в том числе стандартный для ES6 SystemJS.
2. **Асинхронный provide модулей.** Не представляю, зачем и кому это нужно. Гайд YModules тоже не дает разъяснений на этот счет, но похоже, что все затевалось только ради этого пункта. Очень похоже на то, что когда-то команда Яндекса столкнулась с какой-то проблемой, которую проще всего было решить при помощи асинхнонного provide модуля и они даже написали свою модульную систему, которая это умеет. А потом просто решили, что раз она покрывает все удобные им use-cases, то и в инструментах БЕМ следует использовать именно ее. Тем не менее, реального использования в большинстве проектов эта функция не имеет и использовать эту нестандартную модульную систему только ради нее смысла нет.
3. **Возможность передекларации/додекларации модуля.** Эта возможность широко используется в i-bem для того, чтобы составлять единый реестр всех блоков путем **доопределения** модуля i-bem. Аналогичного поведения можно достичь в любой из сущуствующих модульных систем, подключая и подифицирую мутабельный синглтон-модуль. Этот use-case не является серьезным основанием для использования YModules.

В сухом остатке, инструменты навязывают нестандартную модульную систему, которая, на самом деле, не нужна большинству проектов.

Минусы YModules:

1. Для использования сторонних библиотек в рамках данной модульной системы их приходится специально оборачивать в модуль YModules. В некоторых случаях, это осуществляется нетривиальным образом. Это отнимает время на подключение сопровождение модулей.
2. Данная модульная система не поддерживается популярными инструментами статического анализа и типизации (TypeScript, Flow).
3. Самым существенными минусом YModules (из которого вытекают предыдущие два) является то, что она не является стандартной для JavaScript и даже просто популярной. На текущий момент сущестуют две популярные модульные системы: CommonJS и AMD, которые покрывают большинство потребностей пользователей и используются в подавляющем большинстве интернет проектов. Более того, в  стандарте ES6 предусмотрена модульная система SystemJS, поддержка которой появляется во все большем количестве инструментов и популярных сборщиков.
















